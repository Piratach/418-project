# 57-152 Homework Solver
Bas Yoovidhya & Jonathan Loungani

## Summary
Imagine this: you are a second semester senior taking [57-152] Harmony I. 
Being a second semester senior, you have not completed any assignments in the course since the 
first week of classes—an absolute travesty.  
  
On a completely unrelated note, we are going to implement an optimized harmonization tool that can compose music subject 
to the constraints of 18th century European classical music. We will compare approaches to parallelizing the 
implementation on GPU and multi-core platforms.  

## Background
We are interested in writing a program that can compose music in accordance with Eighteenth century style functional 
harmony. This style of music is suitable for programmatic composition because it is characterized by a set of hard 
rules about when certain notes and chords can be used. Thus, exercises in classes like Harmony I tend to be more like 
constraint-solving puzzles than works of artistry.  
  
We will design an expert-system that will generate a valid harmonization when provided with one of the voices of a 
four-part harmony exercise. The main algorithm will be a back-tracking algorithm that will search for a valid solution to 
satisfy the aforementioned constraints that are provided by functional harmonic analysis. There are multiple avenues to 
explore parallelization in the harmony, such as by independent voice, by chord, or by measure. We will experiment with 
parallelization techniques to improve the performance of the program and discuss the results in terms of their impacts 
on performance and “musical correctness.”


## The Challenge
One difficulty of this project that we will face early on is determining what the "best" way to represent chords in our 
program is. Depending on our internal representation, this could affect cache misses. For example, if our chord 
representation is too big, then cache lines would be filled up quickly, leading to fewer data being maintained in each 
cache lines.
  
Because certain chords in the music relies on the previous chord to be "musically correct", parallelizing over all the 
possible chord positions and notes can make a huge impact on the "musical correctness" of the result.
As stated earlier, one approach to this could be to utilize a back-tracking algorithm, but it is also entirely possible 
that this approach is restricted in terms of what can be parallelized, and therefore yields lower speed-ups.
It may be "better" to parallelize over all the chords, likely achieving better speed-ups, while trying to 
maintain the validity of the final harmonization - similar in some sense to the wire problems in assignment 3 and 4.
The trade-off between correctness and computation time will have to be explored.


## Resources
We will be starting from scratch, and will be using Professor John Ito's Harmony [website](https://www.andrew.cmu.edu/user/johnito/music_theory/harmony1and2/HarmMain.html) for the rules and constraints that determine the validty of chords.
The other resources we will be utilizing is some (currently unknown) library in C++ for reading and writing MIDI data,
potentially OpenMP, OpenMPI, and CUDA.
We will be using Gates Cluster Machines for this project.  
  

## GOALS AND DELIVERABLES
### 75% goal
Our solver should be able to output “solutions” that are correct and follow all the constraints specified. 
The solver should be able to utilize a parallel implementation to speed-up computations, but the results may not 
be fully correct.

### PLAN TO ACHIEVE (100% goal)
Our solver should be able to output “solutions” that are correct and follow all the constraints specified. 
Furthermore, our solver should be able to utilize at least one parallel solution to speed-up the computations,
and still yield correct results.

### HOPE TO ACHIEVE (125% goal)
Our solver should be able to output “solutions” that are correct and follow all the constraints specified. 
Furthermore, our solver should be able to utilize several parallel solutions to speed-up the computations, allowing us 
to explore the different trade-offs between each solution. If time permits, we could also implement more relaxed 
constraints with more variety of chord progressions (from Harmony II). 


## Demo Description
Our demo will be an interactive demo that demonstrates the capability of this solver. We hope to be able to show the 
MIDI generated by this solver, and briefly explain why it is correct. In addition, we will also demonstrate each of the 
approaches we took to parallelize the program, play the different results, and explain the potential trade-offs 
between speed-ups/correctness for each approach.


## Platform Choice
We are planning to use C++ as the programming language for this project. We believe that this is the best option for this 
project, because we are both familiar with the language, and there are a lot of libraries available for writing/reading 
MIDI. Additionally, we will be familiar with all the different methods of parallel programming used in each of our 
assignments. We will be utilizing the Gates Clusters Machine for similar reasons.


## Schedule

**Week 1 (March 28 - April 3)**
* Be able to write to and read from MIDI files
* Decide on how to represent notes/chords internally
* Decide on the first parallel approach to this problem
* Outline the sequential implementation


**Week 2 (April 4 - April 10)**
* Implement the sequential version of the program
* Debug as needed


**Week 3 (April 11 - April 17)**
* Sequential implementation should be working correctly
* Outline parallel implementation
* Start working on the parallel implementation


**Week 4 (April 18 - April 24)**
* Finish off parallel implementation
* Start analysis
* Start second parallel implementation if there is time


**Week 5 (April 25 - May 1)**
* Finish off analysis
* Write final report
* Prepare for demo


**Week 6 (May 2 - May 5)**
* Prepare for demo


# MILESTONE

## Progress
We started by creating structures / classes for representing the following objects in our model
* Absolute pitches (e.g. the precise musical pitch “middle C” or C4)
* Notes (generalized notion of musical pitch, formulated in terms of musical scale degrees ^1 through ^7)
* Voicings (ordered “vertical slice” of four notes—each note corresponds to one of the choral voices: soprano, alto, tenor, and bass)
* Chords (sets of constraints on notes within a vertical slice)

This constitutes all of the most fundamental objects in the model, but in the future we may want to add further structures for generalizing constraints between chords.

With those structures in place, we then outlined a sequential implementation of the constraint solver using our MVP set of constraints and chords, namely I, IV, and V chords in root position, with all voicings of chords being valid relative to that vertical slice. We are still debugging the sequential implementation. We also wrote code using a library to convert MIDI input into our internal representation of notes, and our voicing representation to MIDI output. We have not yet written the code for the main solver algorithm, but we have almost everything necessary to begin doing that.

Currently, we are behind schedule since we were to begin debugging our sequential implementation this week. However, we believe that with a few sleepless nights, we can quickly get back on track.

## Deliverable Assessment
There is some uncertainty due to the unknown amount of time it may take to debug our sequential and parallel implementations. We may also end up using a subset of the features (i.e. chords and their constraints) that we had originally hoped to implement in our solver.

Our current intended set of deliverables is as follows:
Our solver should be able to output “solutions” that are correct and follow all the constraints specified. Furthermore, our solver should be able to utilize at least one parallel solution to speed-up the computations, and still yield correct results. 
We would like our solver to be able use the following chords correctly (according to the standards and practices of 18th century Western composers): I, IV, V, I6, V6, V7
Cumulatively, this corresponds to the following categories of constraints:
* Voicing invariants 
  * e.g. the absolute pitches corresponding to notes within a voicing must be sorted from high to low according to soprano, alto, tenor, bass order
* Inter-voicing invariants 
  * e.g. ”parallel fifths”—there cannot be a musical interval of a perfect fifth between the same two voices in consecutive voicings
* Voicing constraints relative to a chord 
  * e.g. a IV chord voicing must contain only notes with degrees ^4, ^6, and ^2
* Inter-chord constraints 
  * e.g. “retrogression”—a V chord cannot immediately precede a IV chord
* Inter-voicing constraints relative to chords
  * e.g. in the voicing of a V7 chord, one voice will have a note with degree ^4. In the voicing that immediately follows the V7 voicing, the voice that had the note with degree ^4 must subsequently have a note with degree ^3.

## Demo Description
Our demo will be an interactive demo that demonstrates the capability of this solver. We hope to be able to show the MIDI generated by this solver, and briefly explain why it is correct. In addition, we will also demonstrate each of the approaches we took to parallelize the program, play the different results, and explain the potential trade-offs between speed-ups/correctness for each approach.

## Updated Schedule
**Week 1 (March 28 - April 3)**
Be able to write to and read from MIDI files (done)
Decide on how to represent notes/chords internally (done)
Decide on the first parallel approach to this problem (done)
Outline the sequential implementation (done)

**Week 2 (April 4 - April 10)**
* Implement the sequential version of the program
* Debug as needed (in progress)

**Week 3a (April 11 - April 14)**
* Sequential implementation should be working correctly
* Outline parallel implementation
* (Bonus) Outline another parallel implementation that might be more parallel but affects correctness

**Week 3b (April 14 - 17)**
* Finish the parallel implementation by the weekend
* Get preliminary results for current implementation
* (Bonus)  Start working on the other parallel implementation

**Week 4a (April 18 - April 21)**
* Add all the others constraints.
* Optimize current implementation.
* (Bonus) Add parallel algorithm that chooses a solution based on soft constraints
* (Bonus) Finish other parallel implementation

**Week 4b (April 21 - 24)**
* Perform analysis and get results
* (Bonus) Perform analysis for other implementation

**Week 5a (April 25 - April 29)**
* Finish off analysis
* Write final report

**Week 5b (April 29 - May 1)**
* Prepare for demo

**Week 6 (May 2 - May 5)**
* Prepare for demo

## Main Concerns
Our main concern is simply the unknown of coding the parallel implementation.
